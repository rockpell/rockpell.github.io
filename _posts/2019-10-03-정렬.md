---
title: "정렬"
date: 2019-10-03T01:00:00-04:00
categories:
  - Algorithm
tags:
  - study
---
# 정렬
제자리(in place) 알고리즘 : 입력 배열 이외의 추가 기억장소의 수가 상수 개를 넘지 않음

안정적(stable) 알고리즘 : 같은 키 값을 가지는 레코드의 상대적인 위치가 정렬 후에도 유지

## 거품정렬(Bubble Sort)
안정적인 제자리 정렬
### 시간복잡도
 - 평균: O(n^2)

```java
void bubbleSort(int[] arr) {
    int temp = 0;
	for(int i = 0; i < arr.length; i++) {
		for(int j= 1 ; j < arr.length-i; j++) {
			if(arr[j]<arr[j-1]) {
				temp = arr[j-1];
				arr[j-1] = arr[j];
				arr[j] = temp;
			}
		}
	}
	System.out.println(Arrays.toString(arr));
}
```
## 선택정렬(Selection Sort)
제자리 정렬, 불안정 정렬

최소값을 찾아 0번 인덱스부터 차례대로 교환한다.

### 시간복잡도
 - 평균: O(n^2)

```java
void selectionSort(int[] arr) {
    int indexMin, temp;

    for (int i = 0; i < arr.length - 1; i++) {
        indexMin = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[indexMin]) {
                indexMin = j;
            }
        }
        temp = arr[indexMin];
        arr[indexMin] = arr[i];
        arr[i] = temp;
    }
}
```

## 삽입정렬
제자리 정렬, 안정적 정렬

### 시간복잡도
 - 평균: O(n^2)
 
```java
void insertionSort(int[] arr) {
        for(int i = 1 ; i < arr.length ; i++){
            int temp = arr[i];
            int index = i - 1;

            while( (index >= 0) && ( arr[index] > temp ) ) {
                arr[index + 1] = arr[index];
                index--;
            }
            arr[index + 1] = temp;
        }
    }
```
