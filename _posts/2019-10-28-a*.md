---
title: "a*"
date: 2019-11-03T17:50:00-04:00
categories:
  - Algorithm
tags:
  - study
---

# A* 알고리즘

```java
import java.util.*;
import java.io.*;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String args[]) throws Exception {
        InputStreamReader reader = new InputStreamReader(System.in);
        BufferedReader bufReader = new BufferedReader(reader);
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String input = bufReader.readLine();
        String[] inputs = input.split(" ");

        int x = Integer.parseInt(inputs[1]);
        int y = Integer.parseInt(inputs[0]);

        int[][] map = new int[y][x];

        // S는 출발지: 2
        // F는 도착지: 3
        // X는 장애물: 1
        // O는 빈칸: 0
        int startX = 0, startY = 0;
        int endX = 0, endY = 0;

        for(int i = 0; i < y; i++){
            input = bufReader.readLine();
            for(int p = 0; p < x; p++){
                switch (input.charAt(p)){
                    case 'X':
                        map[i][p] = 1;
                        break;
                    case 'S':
                        map[i][p] = 2;
                        startX = p;
                        startY = i;
                        break;
                    case 'F':
                        map[i][p] = 3;
                        endX = p;
                        endY = i;
                        break;
                }
            }
        }

        Graph graph = new Graph(x, y);
        graph.inputData(map);
        graph.aStar(startX, startY, endX, endY);
    }
}

// S: 출발 2
// O: 빈공간 0
// F: 도착 3
// X: 장애물 1

class Graph{
    private final int moveCost = 10;
    private int maxX, maxY;
    Node[][] nodeMap;

    public Graph(int sizeX, int sizeY){
        maxX = sizeX;
        maxY = sizeY;
        nodeMap = new Node[maxY][maxX];
    }

    public void inputData(int[][] data){
        for(int y = 0; y < data.length; y++){
            for(int x = 0; x < data[0].length; x++){
                if(data[y][x] != 1){
                    nodeMap[y][x] = new Node(x, y);
                }
            }
        }
    }

    public ArrayList<Node> getNeighbor(Node node){
        int x = node.x;
        int y = node.y;
        ArrayList<Node> result = new ArrayList<>();

        if(x + 1 < maxX){
            if(nodeMap[y][x + 1] != null){
                result.add(nodeMap[y][x + 1]);
            }
        }
        if(x > 0){
            if(nodeMap[y][x - 1] != null){
                result.add(nodeMap[y][x - 1]);
            }
        }
        if(y + 1 < maxY){
            if(nodeMap[y + 1][x] != null){
                result.add(nodeMap[y + 1][x]);
            }
        }
        if(y > 0){
            if(nodeMap[y - 1][x] != null){
                result.add(nodeMap[y - 1][x]);
            }
        }
        return result;
    }

    public void aStar(int startX, int startY, int endX, int endY){
        PriorityQueue<Node> openList = new PriorityQueue<>();
        ArrayList<Node> closeList = new ArrayList<>();

        Node startNode = nodeMap[startY][startX];
        Node endNode = nodeMap[endY][endX];

        openList.offer(startNode);

        while(!openList.isEmpty()){
            Node current = openList.poll();
            if(current.equals(endNode)){
                System.out.println("find!!");
//                printPath(current);
                printDist(current);
                return;
            }
            closeList.add(current);

            ArrayList<Node> neighbors = getNeighbor(current);

            for(Node item : neighbors){
                if(!closeList.contains(item)){
                    double g = current.g + moveCost;
                    double f = g + calDistance(item, endNode);
                    if(!openList.contains(item)){
                        item.parent = current;
                        item.g = g;
                        item.f = f;
                        openList.offer(item);
                    }
                    else{
                        if(f < item.f) {
                            item.parent = current;
                            item.g = g;
                            item.f = f;
                        }
                    }
                }
            }
        }
        System.out.println("Not Found");
    }

    private double calDistance(Node n1, Node n2){
        double x = n1.x - n2.x;
        double y = n1.y - n2.y;
        return Math.sqrt(x * x + y * y);
    }

    private void printPath(Node node){
        System.out.println("x: " + node.x + "  y: " + node.y);

        while(node.parent != null){
            node = node.parent;
            System.out.println("x: " + node.x + "  y: " + node.y);
        }
    }

    private void printDist(Node node){
        int cost = 0;
        while(node.parent != null){
            ++cost;
            node = node.parent;
        }
        System.out.println("dist: " + cost);
    }
}

class Node implements Comparable<Node>{
    int x;
    int y;
    double f, g;
    Node parent;

    public Node(int x, int y){
        this.x = x;
        this.y = y;
    }

    @Override
    public int compareTo(Node target) {
        if(this.f > target.f)
            return 1;
        else if(this.f < target.f)
            return -1;
        return 0;
    }
}
```
