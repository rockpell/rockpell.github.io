---
title: "a*"
date: 2019-10-28T21:00:00-04:00
categories:
  - algorithm
tags:
  - study
---

# A* 알고리즘

미완성

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <map>
#include <algorithm>
#include <string>

using namespace std;

#define MOVE_COST = 1;

class Node {
private:
	int x;
	int y;
	double f;
	double g;
	double h;
	Node* parent;
	vector<Node> neighbors;
public:
	Node(int x, int y) {
		this->x = x;
		this->y = y;
	}
};

class Graph {
private:
	map<pair<int, int>, Node*> nodeMap;

public:
	void inputNodes(int** nodeData, int xLength, int yLength);
	void aStar();
};

void Graph::inputNodes(int** nodeData, int xLength, int yLength) {
	for (int y = 0; y < yLength; ++y) {
		for (int x = 0; x < xLength; ++x) {
			cout << nodeData[y][x];
			if (nodeData[y][x] != 1) {
				nodeMap.insert(make_pair(make_pair(y, x), new Node(y, x)));
			}
		}
	}
}

void Graph::aStar() {
	priority_queue<Node> openList;
	vector<Node> closeList;



}

int main() {
	int x = 0;
	int y = 0;
	int startX, startY;
	int endX, endY;
	int** data;
	string input;

	cin >> y >> x;
	// S는 출발지: 2
	// F는 도착지: 3
	// X는 장애물: 1
	// O는 빈칸: 0
	

	data = new int*[y];
	for (int i = 0; i < y; ++i)
		data[i] = new int[x];

	for (int i = 0; i < y; ++i) {
		cin >> input;
		for (int p = 0; p < x; ++p) {
			switch (input[p])
			{
			case 'O':
				data[i][p] = 0;
				break;
			case 'X':
				data[i][p] = 1;
				break;
			case 'S':
				data[i][p] = 2;
				startX = p;
				startY = i;
				break;
			case 'F':
				data[i][p] = 3;
				endX = p;
				endY = i;
				break;
			}
		}
	}

	Graph graph;

	graph.inputNodes(data, x, y);

	return 0;
}
```

```java
import java.util.*;
import java.io.*;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String args[]) throws Exception {
        InputStreamReader reader = new InputStreamReader(System.in);
        BufferedReader bufReader = new BufferedReader(reader);
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String input = bufReader.readLine();
        String[] inputs = input.split(" ");

        int x = Integer.parseInt(inputs[1]);
        int y = Integer.parseInt(inputs[0]);

        int[][] map = new int[y][x];
        boolean[][] visited = new boolean[y][x];

        // S는 출발지: 2
        // F는 도착지: 3
        // X는 장애물: 1
        // O는 빈칸: 0
        int startX = 0, startY = 0;
        int endX = 0, endY = 0;

        for(int i = 0; i < y; i++){
            input = bufReader.readLine();
            for(int p = 0; p < x; p++){
                switch (input.charAt(p)){
                    case 'X':
                        map[i][p] = 1;
                        visited[i][p] = true;
                        break;
                    case 'S':
                        map[i][p] = 2;
                        visited[i][p] = true;
                        startX = p;
                        startY = i;
                        break;
                    case 'F':
                        map[i][p] = 3;
                        endX = p;
                        endY = i;
                        break;
                }
            }
        }

        Graph graph = new Graph(x, y);
        graph.inputData(map);
        graph.aStar(startX, startY, endX, endY);
    }
}

// S: 출발 2
// O: 빈공간 0
// F: 도착 3
// X: 장애물 1

class Graph{
    private final int moveCost = 10;
    private int maxX, maxY;
    Node[][] nodeMap;

    public Graph(int sizeX, int sizeY){
        maxX = sizeX;
        maxY = sizeY;
        nodeMap = new Node[maxY][maxX];
    }

    public void inputData(int[][] data){
        for(int y = 0; y < data.length; y++){
            for(int x = 0; x < data[0].length; x++){
                if(data[y][x] != 1){
                    nodeMap[y][x] = new Node(x, y);
                }
            }
        }
    }

    public ArrayList<Node> getNeighbor(Node node){
        int x = node.x;
        int y = node.y;
        ArrayList<Node> result = new ArrayList<>();

        if(x + 1 < maxX){
            if(nodeMap[y][x + 1] != null){
                result.add(nodeMap[y][x + 1]);
            }
        }
        if(x > 1){
            if(nodeMap[y][x - 1] != null){
                result.add(nodeMap[y][x - 1]);
            }
        }
        if(y + 1 < maxY){
            if(nodeMap[y + 1][x] != null){
                result.add(nodeMap[y + 1][x]);
            }
        }
        if(y > 1){
            if(nodeMap[y - 1][x] != null){
                result.add(nodeMap[y - 1][x]);
            }
        }
        return result;
    }

    public void aStar(int startX, int startY, int endX, int endY){
        PriorityQueue<Node> openList = new PriorityQueue<>();
        ArrayList<Node> closeList = new ArrayList<>();

        Node startNode = nodeMap[startY][startX];
        Node endNode = nodeMap[endY][endX];

        openList.offer(startNode);

        while(!openList.isEmpty()){
            Node current = openList.poll();

            if(current.equals(endNode)){
                System.out.println("find!!");
//                printPath(current);
                printDist(current);
                return;
            }
            closeList.add(current);

            ArrayList<Node> neighbors = getNeighbor(current);

            for(Node item : neighbors){
                double g = current.g + moveCost;
                double f = g + calDistance(item, endNode);

                if(closeList.contains(item)){
                    if(item.g == 0) {
                        item.g = g;
                        item.f = f;
                    }

                    if(f > item.f)
                        continue;
                }

                if(!openList.contains(item) || f < item.f){
                    item.parent = current;
                    item.g = g;
                    item.f = f;
                    if(!openList.contains(item))
                        openList.offer(item);
                }
            }

        }
        System.out.println("Not Found");
    }

    private double calDistance(Node n1, Node n2){
        double x = n1.x - n2.x;
        double y = n1.y - n2.y;
        return Math.sqrt(x * x + y * y);
    }

    private void printPath(Node node){
        System.out.println("x: " + node.x + "  y: " + node.y);

        while(node.parent != null){
            node = node.parent;
            System.out.println("x: " + node.x + "  y: " + node.y);
        }
    }

    private void printDist(Node node){
        int cost = 0;
        while(node.parent != null){
            ++cost;
            node = node.parent;
        }
        System.out.println("dist: " + cost);
    }
}

class Node implements Comparable<Node>{
    int x;
    int y;
    double f, g;
    Node parent;

    public Node(int x, int y){
        this.x = x;
        this.y = y;
    }

    @Override
    public int compareTo(Node target) {
        if(this.f > target.f)
            return 1;
        else if(this.f < target.f)
            return -1;
        return 0;
    }
}
```
