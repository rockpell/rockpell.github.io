---
title: "c++"
date: 2019-11-21T22:20:00-04:00
categories:
  - c++
tags:
  - study
---

# c++ 기본 개념 학습을 위한 정리

## 상속, 가상함수
### 상속
오버라이딩: 기반 클래스(부모클래스)의 함수와 같은 이름의 함수를 파생 클래스(자식클래스)에서 정의하여 해당 함수가 호출되게 만드는 것

is-a: 모든 상속관계는 is-a 관계라고 볼 수 있다.

has-a: 한 클래스가 다른 클래스를 가지고 있는 관계

업캐스팅: 파생 클래스를 기반 클래스로 캐스팅하는 것

다운 캐스팅: 기반 클래스를 파생클래스로 캐스팅하는 것

### 가상 함수
virtual 키워드를 붙여 가상 함수를 사용 할 수 있다. ex)```virtual void method()```

가상 함수는 어떤 함수를 실행 할 지 런타임시에 결정되는 동적바인딩이 수행된다.

정적바인딩은 컴파일시에 실행할 함수가 정해진다.

가상함수를 오버라이드하는 경우 override 키워드를 이용하여 명시적으로 나타낼 수 있음 ex)```void method() override```

다형성(polymorphism)은 가상함수를 이용하여 하나의 메소드를 호출하여도 여러 객체에 따라 다른 일을 하게 만드는 것을 의미한다.

가상함수가 포함된 클래스들은 각자 vtable을 가지고 있으며 함수 호출 시 vtable에 정의된 바에 따라 기반 클래스 혹은 파생 클래스의 함수를 호출한다.

순수 가상 함수: 반드시 오버라이딩 해야하는 가상 함수 ex) ``` virtual void speak() = 0; ```

본체가 없기 때문에, 이 함수를 호출하는 것은 불가능하다.

추상 클래스: 순수 가상 함수를 하나 이상 포함하고 있는 클래스, 순수 가상 함수를 구현하지 않으면 인스턴스화가 불가능하다.

## 템플릿
template <typename T> 과 같이 사용

컴파일시 컴파일러가 타입에 맞도록 치환하여 코드로 생성한다.

인스턴스화 되지 않은 코드에서는 치환되지 않는다.(생성되지 않기 때문에)

ex) T -> string,  Vector<string>

## STL
### vector
 - begin(): 첫번째 원소를 가리키는 iterator 반환
 - end(): 마지막 원소 한 칸 뒤를 가리키는 iterator 반환
 - push_back(const T& x): 벡터 끝에 원소를 추가한다. 현재의 마지막 원소 뒤에 새로운 원소를 추가하며, 그 원소의 값은 x 의 복사본으로 초기화 된다.
capacity 와 벡터 size 가 같다면 내부적으로 재할당이 일어나게 된다. 이 때 이전에 사용되었던 반복자(iterator) , 레퍼런스, 포인터들은 사용할 수 없음
 
### algorithm
 - sort
 - stable_sort
 - partial_sort
 - remove
 - remove_if
 - 람다함수
	[capture list] (받는 인자) -> 리턴 타입 { 함수 본체 } 또는
  
	[capture list] (받는 인자) { 함수 본체 }
	- 캡처리스트
	 - [] : 아무것도 캡쳐 안함
	 - [&a, b] : a 는 레퍼런스로 캡쳐하고 b 는 (변경 불가능한) 복사본으로 캡쳐
	 - [&] : 외부의 모든 변수들을 레퍼런스로 캡쳐
	 - [=] : 외부의 모든 변수들을 복사본으로 캡쳐
 - transform (시작 반복자, 끝 반복자, 결과를 저장할 컨테이너의 시작 반복자, Pred)
 - find
 - find_if
 - any_of
 - all_of

### 참고 자료
- 모두의 코드 C++
