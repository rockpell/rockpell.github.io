---
title: "c++"
date: 2019-12-15T19:00:00-04:00
categories:
  - c++
tags:
  - study
---

# c++ 기본 개념 학습을 위한 정리

## 상속, 가상함수
### 상속
오버라이딩: 기반 클래스(부모클래스)의 함수와 같은 이름의 함수를 파생 클래스(자식클래스)에서 정의하여 해당 함수가 호출되게 만드는 것

is-a: 모든 상속관계는 is-a 관계라고 볼 수 있다.

has-a: 한 클래스가 다른 클래스를 가지고 있는 관계

업캐스팅: 파생 클래스를 기반 클래스로 캐스팅하는 것

다운 캐스팅: 기반 클래스를 파생클래스로 캐스팅하는 것

### 가상 함수
virtual 키워드를 붙여 가상 함수를 사용 할 수 있다. ex)```virtual void method()```

가상 함수는 어떤 함수를 실행 할 지 런타임시에 결정되는 동적바인딩이 수행된다.

정적바인딩은 컴파일시에 실행할 함수가 정해진다.

가상함수를 오버라이드하는 경우 override 키워드를 이용하여 명시적으로 나타낼 수 있음 ex)```void method() override```

다형성(polymorphism)은 가상함수를 이용하여 하나의 메소드를 호출하여도 여러 객체에 따라 다른 일을 하게 만드는 것을 의미한다.

가상함수가 포함된 클래스들은 각자 vtable을 가지고 있으며 함수 호출 시 vtable에 정의된 바에 따라 기반 클래스 혹은 파생 클래스의 함수를 호출한다.

순수 가상 함수: 반드시 오버라이딩 해야하는 가상 함수 ex) ``` virtual void speak() = 0; ```

본체가 없기 때문에, 이 함수를 호출하는 것은 불가능하다.

추상 클래스: 순수 가상 함수를 하나 이상 포함하고 있는 클래스, 순수 가상 함수를 구현하지 않으면 인스턴스화가 불가능하다.

## 템플릿
template <typename T> 과 같이 사용

컴파일시 컴파일러가 타입에 맞도록 치환하여 코드로 생성한다.

인스턴스화 되지 않은 코드에서는 치환되지 않는다.(생성되지 않기 때문에)

ex) T -> string,  Vector<string>

c++11 using을 이용하면 typedef 대신에 사용가능하다.

```c++
typedef void (*func)(int, int);
using func = void (*)(int, int);
```

auto: 오른쪽의 연산자를 통해서 컴파일러가 타입을 추론, 템플릿과 같은 방식으로 타입을 추론한다.

## 리터럴 연산자
- ""s: string으로 추론하여 정의 ex) auto str = "hello"s;
- L"": wchar_t[]으로 정의
- R"": Raw string literal, 모든 문자가 그대로 저장(개행문자, 주석 표시 표함)
- u8"": UTF-8 문자열
- u"": UTF-16 문자열

## string_view
- 문자열 읽기만 필요할 때 사용
- C++ 17부터 도입
- 메모리 할당을 하지 않는다
- 원본이 사라지면 문제가 생긴다
- `const char*`을 매개변수로 사용하면 문자열 길이를 다시 계산해야하지만 string_view는 문자열 길이를 가지고 있다.

## STL
### vector
 - []연산자, at(): 임의의 위치 원소에 접근
 - begin(): 첫번째 원소를 가리키는 iterator 반환
 - end(): 마지막 원소 한 칸 뒤를 가리키는 iterator 반환
 - push_back(const T& x): 벡터 끝에 원소를 추가한다. 현재의 마지막 원소 뒤에 새로운 원소를 추가하며, 그 원소의 값은 x 의 복사본으로 초기화 된다.
capacity 와 벡터 size 가 같다면 내부적으로 재할당이 일어나게 된다. 이 때 이전에 사용되었던 반복자(iterator) , 레퍼런스, 포인터들은 사용할 수 없음
시간복잡도는 amortized O(1)이 된다.
 - insert, erase: 임의의 위치에 원소 삽입 및 제거, 시간복잡도 O(n)
 
### list
링크드리스트
 - begin(): 첫번째 원소를 가리키는 iterator 반환
 - end(): 마지막 원소 한 칸 뒤를 가리키는 iterator 반환
 - push_back(const T& x): 마지막 위치에 우너소 삽입, 시간복잡도 O(1)
 - insert, erase: 임의의 위치에 원소 삽입 및 제거, 시간복잡도 O(1)

### algorithm
 - sort: 정렬
 - stable_sort: 순서를 보장하여 정렬, sort보다 느림
 - partial_sort: 원하는 범위의 정렬된 원소를 원할때 사용하는 정렬함수, 그 외의 원소는 무작위로 나타난다. ex) 0~2번째 순서까지만 정렬되도록
 - remove: 원하는 원소의 뒤에 있는 원소를 앞으로 이동시킨다. erase와 함께 사용하여 원소 제거시에 사용
		
		vec.erase(remove(vec.begin(), vec.end(), 3), vec.end());
 - remove_if: remove와 기본적으로 동일하게 작동하며 조건을 추가할 수 있다.
 - 람다함수
	[capture list] (받는 인자) -> 리턴 타입 { 함수 본체 } 또는
  
	[capture list] (받는 인자) { 함수 본체 }
	- 캡처리스트
	 - [] : 아무것도 캡쳐 안함
	 - [&a, b] : a 는 레퍼런스로 캡쳐하고 b 는 (변경 불가능한) 복사본으로 캡쳐
	 - [&] : 외부의 모든 변수들을 레퍼런스로 캡쳐
	 - [=] : 외부의 모든 변수들을 복사본으로 캡쳐
 - transform (시작 반복자, 끝 반복자, 결과를 저장할 컨테이너의 시작 반복자, Pred): 전체 혹은 일부를 순회하면서 값을 수정, 모든 원소에 1을 더하는 것과 같은 단순 작업에 사용
 - find: 원하는 원소를 찾을 때 사용, 반복자를 반환, 선형탐색을 하기 때문에 사용하는 컨테이너에 탐색 함수가 있다면 이 함수를 사용하면 느리다.(vector에는 없기때문에 이 함수를 사용)
 - find_if: 조건에 맞는 원소 찾을 때 사용
 - any_of: 조건 중 하나라도 일치하는 원소가 있는지 true, false 반환
 - all_of: 모든 원소가 조건에 일치하는지 true, false반환

## 예외처리
### throw
예외를 던질때 사용

예외로 전달하는 객체는 아무거나 가능하다

std::exception을 상속받은 객체를 만들어 쓰거나 사용하는것이 좋다.

ex) `throw std::out_of_range("vector 의 index 가 범위를 초과하였습니다.");`

overflow_error, length_error, runtime_error등 

### try, catch

try문 내에서 throw 발생시 가장 가까운 catch로 점프

### catch(...)
모든 예외 상황을 처리할 때 사용

### stack unwinding
throw 호출 후 가장 가까운 catch로 점프할때 스택 상에 정의된 객체들을 소멸시키는 과정
(생성자에서 예외 발생 시 소멸자가 호출되지 않는다, catch안에서 알아서 해제시켜줘야함)

### noexcept 키워드
이 키워드가 붙은 함수는 예외가 발생하지 않는다는 것을 컴파일러에게 알려줌(최적화용)

이 키워드가 붙은 함수내에서 throw로 예외 호출시 제대로 처리되지 않고 프로그램이 종료된다 , 소멸자는 기본적으로 noexcept이다.


### 참고 자료
- 모두의 코드 C++
