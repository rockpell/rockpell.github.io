---
title: "다익스트라"
date: 2019-10-22T20:30:00-04:00
categories:
  - Algorithm
tags:
  - study
---

# 다익스트라

참고사이트: [https://hsp1116.tistory.com/42]

```java
import javafx.util.Pair;
import java.util.*;
import java.io.*;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String args[]) throws Exception {
        InputStreamReader reader = new InputStreamReader(System.in);
        BufferedReader bufReader = new BufferedReader(reader);

        Graph graph = new Graph();

        String[] inputs = bufReader.readLine().split(" ");
        String[] inputs2;
        int n = Integer.parseInt(inputs[0]);
        int m = Integer.parseInt(inputs[1]);
        int start = Integer.parseInt(inputs[2]);

        for(int i = 0; i < n; i++)
            graph.addVertex(i + 1);

        graph.initAdj();

        for(int i = 0; i < m; i++){
            int u, v, w;
            inputs2 = bufReader.readLine().split(" ");
            u = Integer.parseInt(inputs2[0]);
            v = Integer.parseInt(inputs2[1]);
            w = Integer.parseInt(inputs2[2]);
            graph.addAdj(u, v, w);
        }
        graph.dijkstra(start);
    }
}

class Vertex implements Comparable<Vertex>{
    public int index; // 정점 번호 1부터 시작한다
    public int dist; // 경로 길이
    public int post; // 이전 정점

    public Vertex(int index, int dist, int post){
        this.index = index;
        this.dist = dist;
        this.post = post;
    }

    public Vertex(int index){
        this.index = index;
        dist = Integer.MAX_VALUE;
    }

    public int compareTo(Vertex vertex){
        return this.dist >= vertex.dist ? 1: -1;
    }
}

class Graph {
    int n;
    ArrayList<Vertex> vertexs = new ArrayList<>();
    PriorityQueue<Vertex> priorityQueue = new PriorityQueue<>();
    ArrayList<ArrayList<Pair<Integer, Integer>>> adj = new ArrayList<>();
    Map<Integer, Pair<Integer, Integer>> map = new HashMap<>();
    // 최단 경로를 저장하기 위한 map. Pair의 첫번째는 경로의 길이, 두 번째는 이전 점정을 의미한다.

    public void initAdj(){
        for(int i = 0; i < n; i++)
            adj.add(new ArrayList<>());
    }

    public void addVertex(int index, int dist){
        vertexs.add(new Vertex(index, dist, index));
        n = vertexs.size();
    }

    public void addVertex(int index){
        vertexs.add(new Vertex(index));
        n = vertexs.size();
    }

    public void addAdj(int u, int v, int w){
        adj.get(u - 1).add(new Pair(v, w));
    }

    public void dijkstra(int start){
        ArrayList<Integer> dist = new ArrayList<>();
        for(int i = 0; i < n; i++)
            dist.add(Integer.MAX_VALUE);

        dist.set(start - 1, 0);
        vertexs.get(start - 1).dist = 0;
        vertexs.get(start - 1).post = start;

        for(int i = 0; i < n; i++)
            priorityQueue.offer(vertexs.get(i));

        map.put(start, new Pair(0, -1));

        while(!priorityQueue.isEmpty()){
            int index = priorityQueue.peek().index - 1;
            int cost = priorityQueue.peek().dist;
            priorityQueue.poll();

            if(dist.get(index) < cost)
                continue;
            for(int i = 0; i < adj.get(index).size(); i++){
                int n = adj.get(index).get(i).getKey();
                int v = adj.get(index).get(i).getValue();

                if(dist.get(n - 1) > dist.get(index) + v){
                    dist.set(n - 1, dist.get(index) + v);
                    Vertex tempVertex = new Vertex(n, dist.get(n - 1), index + 1);
                    priorityQueue.offer(tempVertex);
                    map.put(n, new Pair(dist.get(n - 1), index + 1));
                }
            }
        }

        for(int i = 0; i < n; i++){
            System.out.println(i + "에 대한 최단 경로 길이: " + dist.get(i));
        }

        for(int i = 1; i <= map.size(); i++){ // 정점 번호는 1부터 시작하기 때문에 1부터 출력
            System.out.println("index: " + i + " 이전 정점: " + map.get(i).getValue());
        }
    }
}
```
